#pragma kernel CSMain

RWStructuredBuffer<float3> _particlePositions;
RWStructuredBuffer<float3> _particleVelocities;

float _deltaTime;


// Simulation Settings
const int _particleCount;
const float _particleRadius;

const float2 _boundsSize;
const float2 _obstacleSize;
const float2 _obstacleCentre;

const float _collisionDamping;
const float _gravity;
const float _stiffness;
const float _forceDamping;
const float _forceCutoff;
const bool _forceCollisions;


void HandleCollisions(uint id) 
{

	float3 pos = _particlePositions[id];
    float3 vel = _particleVelocities[id];

	// Keep particle inside bounds
	const float2 halfSize = _boundsSize * 0.5;
	float2 edgeDst = halfSize - abs(pos.xy);

	if (edgeDst.x <= 0)
	{
		pos.x = halfSize.x * sign(pos.x);
		vel.x *= -1 * _collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		pos.y = halfSize.y * sign(pos.y);
		vel.y *= -1 * _collisionDamping;
	}


    // Collide particle against the test obstacle
	const float2 obstacleHalfSize = _obstacleSize * 0.5;
	float2 obstacleEdgeDst = obstacleHalfSize - abs(pos.xy - _obstacleCentre);

	if (obstacleEdgeDst.x >= 0 && obstacleEdgeDst.y >= 0)
	{
		if (obstacleEdgeDst.x < obstacleEdgeDst.y) 
		{
			pos.x = obstacleHalfSize.x * sign(pos.x - _obstacleCentre.x) + _obstacleCentre.x;
			vel.x *= -1 * _collisionDamping;
		}
		else 
		{
			pos.y = obstacleHalfSize.y * sign(pos.y - _obstacleCentre.y) + _obstacleCentre.y;
			vel.y *= -1 * _collisionDamping;
		}
	}

	_particlePositions[id] = pos;
    _particleVelocities[id] = vel;
}

float3 CalculateParticleForce(int id)
{
	float3 vel = _particleVelocities[id];
	float3 pos = _particlePositions[id];
	float3 acceleration = {0,0,0};

	// Loop through every other particle. Slows down at large particle count so will in future methods
	// want to put particles into segments on grid, especially for 3d
	for (int i = 0; i < _particleCount; i++) 
	{
		if (i == id) {continue;}
		else 
		{
			float3 rvec = pos - _particlePositions[i];
			float r = length(rvec);
			float3 dir = rvec / (r);

			if (r < _forceCutoff)
			{
				float overlap = _forceCutoff - r;

				float3 relVel = _particleVelocities[i] - vel;
				float relNormalVel = dot(relVel, dir);

				float3 spring = dir * (_stiffness * pow(r,2));
				float3 damping = dir * (-_forceDamping * relNormalVel);
				acceleration += spring + damping;
			}
		}
	}
	return acceleration;
}

// Forces have issues with requiring very small time steps to resolve. We can do this but they slow down the
// simulations. Ive tried another method here but want to change it to a pressure-based method.


// Position based dynamics (almost)
void ExcludeVolumes(int id)
{
	float3 pos = _particlePositions[id];
	float3 vel = _particleVelocities[id];
	float3 correctionSum = 0;
	uint neighbourCount = 0;

	// Loop through every other particle. If radii overlap, moves both particles apart by half the overlap
	for (int i = 0; i < _particleCount; i++) 
	{
		if (i == id) continue;

		float3 rvec = pos - _particlePositions[i];
		float r = length(rvec);
		float minDist = 2.0*_particleRadius;  //(sum radii here if using different radii)
		if (r < minDist)  // overlapping
		{
			float3 dir = rvec / r;
			float overlap = 0.5*(minDist-r);
			correctionSum += dir * overlap;
			neighbourCount++;
		}
	}

	if (neighbourCount > 0) {
		pos += correctionSum/neighbourCount;
		vel += correctionSum/neighbourCount * 50;
	}

	_particleVelocities[id] = vel;
	_particlePositions[id] = pos;
}

// To fix this method over the last iteration, all we needed to do was loop in the ParticleSim2D script
// multiple calls to CSMain per frame, dividing the deltaTime by the same amount. This results in smaller
// distances moved per frame, allliowing the exlcusion correction to be more accurate. 3-5 is a decent range.



void UpdatePositions(uint id, float3 gravity)
{
	float3 acceleration = {0,0,0};

	// Simple suvat with leapfrog approximation for gravity
	if (_forceCollisions) 
	{
		acceleration = gravity + CalculateParticleForce(id);
	} else 
	{
		acceleration = gravity;
		ExcludeVolumes(id);
	}

	float3 pos = _particlePositions[id];
    float3 vel = _particleVelocities[id];

    vel += 0.5f * acceleration * _deltaTime;
    pos += (vel * _deltaTime) + (0.5f * acceleration * _deltaTime * _deltaTime);
    vel += 0.5f * acceleration * _deltaTime;

	_particlePositions[id] = pos;
    _particleVelocities[id] = vel;

	HandleCollisions(id);
}


[numthreads(256, 1, 1)]  // Leave as 256 threads for now
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (id.x >= _particleCount) return;

    float3 pos = _particlePositions[id.x];
    float3 vel = _particleVelocities[id.x];

	float3 gravity = {0, _gravity, 0};

	UpdatePositions(id.x, gravity);
}

