#pragma kernel CSMain

RWStructuredBuffer<float3> _particlePositions;
RWStructuredBuffer<float3> _particleVelocities;

float _deltaTime;


// Simulation Settings
const int _particleCount;
const float _particleInfluenceRadius;

const float2 _boundsSize;
const float2 _obstacleSize;
const float2 _obstacleCentre;

const float _collisionDamping;
const float _gravity;
const float _forceMultiplier;

float3 CalcUnitVector(float3 vec)
{
	float magnitude = sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);
	vec.x = vec.x/magnitude;
	vec.y = vec.y/magnitude;
	vec.y = vec.y/magnitude;
	return vec;
}

void HandleCollisions(uint id) 
{

	float3 pos = _particlePositions[id];
    float3 vel = _particleVelocities[id];

	// Keep particle inside bounds
	const float2 halfSize = _boundsSize * 0.5;
	float2 edgeDst = halfSize - abs(pos.xy);

	if (edgeDst.x <= 0)
	{
		pos.x = halfSize.x * sign(pos.x);
		vel.x *= -1 * _collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		pos.y = halfSize.y * sign(pos.y);
		vel.y *= -1 * _collisionDamping;
	}


    // Collide particle against the test obstacle
	const float2 obstacleHalfSize = _obstacleSize * 0.5;
	float2 obstacleEdgeDst = obstacleHalfSize - abs(pos.xy - _obstacleCentre);

	if (obstacleEdgeDst.x >= 0 && obstacleEdgeDst.y >= 0)
	{
		if (obstacleEdgeDst.x < obstacleEdgeDst.y) {
			pos.x = obstacleHalfSize.x * sign(pos.x - _obstacleCentre.x) + _obstacleCentre.x;
			vel.x *= -1 * _collisionDamping;
		}
		else {
			pos.y = obstacleHalfSize.y * sign(pos.y - _obstacleCentre.y) + _obstacleCentre.y;
			vel.y *= -1 * _collisionDamping;
		}
	}

	_particlePositions[id] = pos;
    _particleVelocities[id] = vel;
}

float3 CalculateParticleForce(int id)
{
	float3 pos = _particlePositions[id];
	float3 acceleration = {0,0,0};

	// Loop through every other particle. Slows down at large particle count so will in future methods
	// want to put particles into segments on grid, especially for 3d
	for (int i = 0; i < _particleCount; i++) {
		if (i == id) {continue;}
		else {
			float3 otherPos = _particlePositions[i];
			float3 dist = otherPos - pos;
			float3 unitDist = CalcUnitVector(dist);
			float scalarDist = dot(dist, dist);
			if (scalarDist < _particleInfluenceRadius) {
				float x = (_particleInfluenceRadius - scalarDist);
				acceleration.xy += - unitDist.xy * x*x * _forceMultiplier;
				  // Only calculating force for self here, but each particle gets checked so the other should get
				  // equal and opposite force
			}
		}
	}

	return acceleration;
}


void UpdatePositions(uint id, float3 gravity)
{
	float3 pos = _particlePositions[id];
    float3 vel = _particleVelocities[id];

	// Simple suvat with leapfrog approximation for gravity
	float3 acceleration = gravity + CalculateParticleForce(id);
    vel += 0.5f * acceleration * _deltaTime;
    pos += (vel * _deltaTime) + (0.5f * acceleration * _deltaTime * _deltaTime);
    vel += 0.5f * acceleration * _deltaTime;

	_particlePositions[id] = pos;
    _particleVelocities[id] = vel;

	HandleCollisions(id);
}


[numthreads(256, 1, 1)]  // Leave as 256 threads for now
void CSMain(int3 id : SV_DispatchThreadID)
{
    if (id.x >= _particleCount) return;

    float3 pos = _particlePositions[id.x];
    float3 vel = _particleVelocities[id.x];

	float3 gravity = {0, _gravity, 0};

	UpdatePositions(id.x, gravity);
}

